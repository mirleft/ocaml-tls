<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tls_miou_unix (tls-miou-unix.Tls_miou_unix)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">tls-miou-unix</a> &#x00BB; Tls_miou_unix</nav><header class="odoc-preamble"><h1>Module <code><span>Tls_miou_unix</span></code></h1><p>Effectful operations using Miou for pure TLS.</p><p>The pure TLS is state and buffer in, state and buffer out. This module uses Miou (and its Unix layer) for communication over the network.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Tls_alert"><a href="#exception-Tls_alert" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Tls_alert</span> <span class="keyword">of</span> <a href="../../tls/Tls/Packet/index.html#type-alert_type">Tls.Packet.alert_type</a></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Tls_failure"><a href="#exception-Tls_failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Tls_failure</span> <span class="keyword">of</span> <a href="../../tls/Tls/Engine/index.html#type-failure">Tls.Engine.failure</a></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Closed_by_peer"><a href="#exception-Closed_by_peer" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Closed_by_peer</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Abstract type of a session.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-file_descr"><a href="#val-file_descr" class="anchor"></a><code><span><span class="keyword">val</span> file_descr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Miou_unix</span>.file_descr</span></code></div><div class="spec-doc"><p><code>file_descr</code> returns the underlying file-descriptor used by the given TLS <i>socket</i>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>read fd buf ~off ~len</code> reads up to <code>len</code> bytes (defaults to <code>Bytes.length buf - off</code> from the given TLS <i>socket</i> <code>fd</code>, storing them in byte sequence <code>buf</code>, starting at position <code>off</code> in <code>buf</code> (defaults to <code>0</code>). It returns the actual number of characters read, between 0 and <code>len</code> (inclusive).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Unix_error</code> <p>raised by the system call <code>Unix.read</code>. The function handles <code>Unix.EINTR</code>, <code>Unix.EAGAIN</code> and <code>Unix.EWOULDBLOCK</code> exceptions and redo the system call.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-really_read"><a href="#val-really_read" class="anchor"></a><code><span><span class="keyword">val</span> really_read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>really_read fd buf ~off ~len</code> reads <code>len</code> bytes (defaults to <code>Bytes.length buf - off</code>) from the given TLS <i>socket</i> <code>fd</code>, storing them in byte sequence <code>buf</code>, starting at position <code>off</code> in <code>buf</code> (defaults to <code>0</code>). If <code>len = 0</code>, <code>really_read</code> does nothing.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Unix_error</code> <p>raised by the system call <code>Unix.read</code>. The function handles <code>Unix.EINTR</code>, <code>Unix.EAGAIN</code> and <code>Unix.EWOULDBLOCK</code> exceptions and redo the system call.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p>if <code>Unix.read</code> returns <code>0</code> before <code>len</code> characters have been read.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write t str ~off ~len</code> writes <code>len</code> bytes (defaults to <code>String.length str - off</code>) from byte sequence <code>str</code>, starting at offset <code>off</code> (defaults to <code>0</code>), to the given TLS <i>socket</i> <code>fd</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Unix_error</code> <p>raised by the syscall call <code>Unix.write</code>. The function handles <code>Unix.EINTR</code>, <code>Unix.EAGAIN</code> and <code>Unix.EWOULDBLOCK</code> exceptions and redo the system call.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Closed_by_peer"><code>Closed_by_peer</code></a> <p>if <code>t</code> is connected to a peer whose reading end is closed. Similar to the <code>EPIPE</code> error for pipe/socket connected.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close flow</code> closes the TLS session and the underlying file-descriptor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span><span class="keyword">val</span> shutdown : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[ `read <span>| `write</span> <span>| `read_write</span> ]</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>shutdown t direction</code> closes the direction of the TLS session <code>t</code>. If <code>`read_write</code> or <code>`write</code> is closed, a TLS close-notify is sent to the other endpoint. If this results in a fully-closed session (or an errorneous session), the underlying file descriptor is closed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-client_of_fd"><a href="#val-client_of_fd" class="anchor"></a><code><span><span class="keyword">val</span> client_of_fd : 
  <span><a href="../../tls/Tls/Config/index.html#type-client">Tls.Config.client</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?read_buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?host</span>:<span><span>[ `host ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Miou_unix</span>.file_descr <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>client_of_flow client ~host fd</code> is <code>t</code>, after client-side TLS handshake of <code>fd</code> using <code>client</code> configuration and <code>host</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p>if we are not able to complete the handshake.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-server_of_fd"><a href="#val-server_of_fd" class="anchor"></a><code><span><span class="keyword">val</span> server_of_fd : 
  <span><a href="../../tls/Tls/Config/index.html#type-server">Tls.Config.server</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?read_buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Miou_unix</span>.file_descr <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>server_of_fd server fd</code> is <code>t</code>, after server-side TLS handshake of <code>fd</code> using <code>server</code> configuration.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>End_of_file</code> <p>if we are not able to complete the handshake.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span><span class="xref-unresolved">X509</span>.Authenticator.t <span class="arrow">&#45;&gt;</span></span> <span><span>(string * int)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>connect authenticator (host, port)</code> is <code>t</code>, a connected TLS connection to <code>host</code> on <code>port</code> using the default configuration and the <code>authenticator</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-epoch"><a href="#val-epoch" class="anchor"></a><code><span><span class="keyword">val</span> epoch : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../tls/Tls/Core/index.html#type-epoch_data">Tls.Core.epoch_data</a> option</span></span></code></div><div class="spec-doc"><p><code>epoch t</code> returns <code>epoch</code>, which contains information of the active session.</p></div></div></div></body></html>
