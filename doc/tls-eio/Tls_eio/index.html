<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tls_eio (tls-eio.Tls_eio)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">tls-eio</a> &#x00BB; Tls_eio</nav><header class="odoc-preamble"><h1>Module <code><span>Tls_eio</span></code></h1><p>Effectful operations using Eio for pure TLS.</p><p>The pure TLS is state and buffer in, state and buffer out. This module uses Eio for communication over the network.</p></header><nav class="odoc-toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#control-of-tls-features">Control of TLS features</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Tls_alert"><a href="#exception-Tls_alert" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Tls_alert</span> <span class="keyword">of</span> <a href="../../tls/Tls/Packet/index.html#type-alert_type">Tls.Packet.alert_type</a></span></code></div><div class="spec-doc"><p><code>Tls_alert</code> exception received from the other endpoint</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Tls_failure"><a href="#exception-Tls_failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Tls_failure</span> <span class="keyword">of</span> <a href="../../tls/Tls/Engine/index.html#type-failure">Tls.Engine.failure</a></span></code></div><div class="spec-doc"><p><code>Tls_failure</code> exception while processing incoming data</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><span>[ `Tls <span>| <span class="xref-unresolved">Eio</span>.Flow.two_way_ty</span> <span>| <span class="xref-unresolved">Eio</span>.Resource.close_ty</span> ]</span> <span class="xref-unresolved">Eio</span>.Std.r</span></span></code></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec value anchored" id="val-server_of_flow"><a href="#val-server_of_flow" class="anchor"></a><code><span><span class="keyword">val</span> server_of_flow : 
  <span><a href="../../tls/Tls/Config/index.html#type-server">Tls.Config.server</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[&gt; <span class="xref-unresolved">Eio</span>.Flow.two_way_ty <span>| <span class="xref-unresolved">Eio</span>.Resource.close_ty</span> ]</span> <span class="xref-unresolved">Eio</span>.Std.r</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>server_of_flow server flow</code> is <code>t</code>, after server-side TLS handshake of <code>flow</code> using <code>server</code> configuration.</p><p>You must ensure a RNG is installed while using TLS, e.g. using <code>Mirage_crypto_rng_unix.use_default ()</code>. Ideally, this would be part of the <code>server</code> config so you couldn't forget it, but for now you'll get a runtime error if you forget.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-client_of_flow"><a href="#val-client_of_flow" class="anchor"></a><code><span><span class="keyword">val</span> client_of_flow : 
  <span><a href="../../tls/Tls/Config/index.html#type-client">Tls.Config.client</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?host</span>:<span><span>[ `host ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[&gt; <span class="xref-unresolved">Eio</span>.Flow.two_way_ty <span>| <span class="xref-unresolved">Eio</span>.Resource.close_ty</span> ]</span> <span class="xref-unresolved">Eio</span>.Std.r</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>client_of_flow client ~host fd</code> is <code>t</code>, after client-side TLS handshake of <code>flow</code> using <code>client</code> configuration and <code>host</code>.</p><p>You must ensure a RNG is installed while using TLS, e.g. using <code>Mirage_crypto_rng_unix.use_default ()</code>. Ideally, this would be part of the <code>client</code> config so you couldn't forget it, but for now you'll get a runtime error if you forget.</p></div></div><h3 id="control-of-tls-features"><a href="#control-of-tls-features" class="anchor"></a>Control of TLS features</h3><div class="odoc-spec"><div class="spec value anchored" id="val-reneg"><a href="#val-reneg" class="anchor"></a><code><span><span class="keyword">val</span> reneg : 
  <span><span class="optlabel">?authenticator</span>:<span class="xref-unresolved">X509</span>.Authenticator.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?acceptable_cas</span>:<span><span class="xref-unresolved">X509</span>.Distinguished_name.t list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?cert</span>:<a href="../../tls/Tls/Config/index.html#type-own_cert">Tls.Config.own_cert</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?drop</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>reneg ~authenticator ~acceptable_cas ~cert ~drop t</code> renegotiates the session, and blocks until the renegotiation finished. Optionally, a new <code>authenticator</code> and <code>acceptable_cas</code> can be used. The own certificate can be adjusted by <code>cert</code>. If <code>drop</code> is <code>true</code> (the default), application data received before the renegotiation finished is dropped.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-key_update"><a href="#val-key_update" class="anchor"></a><code><span><span class="keyword">val</span> key_update : <span><span class="optlabel">?request</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>key_update ~request t</code> updates the traffic key and requests a traffic key update from the peer if <code>request</code> is provided and <code>true</code> (the default). This is only supported in TLS 1.3.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-epoch"><a href="#val-epoch" class="anchor"></a><code><span><span class="keyword">val</span> epoch : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../tls/Tls/Core/index.html#type-epoch_data">Tls.Core.epoch_data</a>, unit)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>epoch t</code> returns <code>epoch</code>, which contains information of the active session.</p></div></div></div></body></html>
